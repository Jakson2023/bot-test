{
  "html/css": [
    {
      "id": 1,
      "text": "Для чого потрібно вказувати DOCTYPE?",
      "hasOptions": false,
      "answer": "DOCTYPE вказує тип поточного документа. Це необхідно, щоб браузер розумів, як слід інтерпретувати поточну веб-сторінку, оскільки HTML існує у кількох версіях. " 
    },
    {
      "id": 2,
      "text": "Що буде, якщо не вказати DOCTYPE на початку документа?",
      "hasOptions": false,
      "answer":"Браузер спробує відобразити сторінку в режимі сумісності (quirks mode). Це може призвести до того, що в різних браузерах сторінка відображатиметься по-різному."
    },
    {
      "id": 3,
      "text": "Для чого потрібні мета-теги?",
      "hasOptions": false,
      "answer":"Мета-теги – це теги, які надають пошуковим системам додаткову інформацію про сторінку сайту. Наприклад, механізми пошукових систем звертаються до мета-тегів для отримання опису сайту, ключових слів та інших даних. Мета-теги для сайту розміщуються всередині head."
    },
    {
      "id": 4,
      "text": "Чим відрізняється блоковий елемент від рядкового?",
      "hasOptions": false,
      "answer": "Блокові елементи є основою, яка використовується для верстки сторінок. Такий елемент є прямокутником, який за замовчуванням займає всю доступну ширину сторінки, а висота елемента залежить від його вмісту. Такий елемент завжди починається з нового рядка. Блоковий елемент може містити в собі інші блокові та рядкові елементи. Приклади блокових елементів: div, p, ul, ol, h1. На відміну від блокового, рядковий елемент не переноситься на новий рядок, а розташовується у тому ж рядку, що й попередній елемент. Ширина рядкового елемента залежить від його вмісту. Блокові елементи не можна вкладати в рядкові. Приклади рядкових елементів: a, span, strong, em, img."
    },
    {
      "id": 5,
      "text": "Чому деякі символи можуть відображатися у вигляді квадратів?",
      "hasOptions": false,
      "answer": "Це може виникати через те, що деякі браузери можуть не підтримувати певні символи операційної системи. Також може відрізнятися кодування. Або не підключено потрібний шрифт з іконками."
    },
    {
      "id": 6,
      "text": "Які типи заголовків є в HTML?",
      "hasOptions": false,
      "answer": "HTML підтримує шість різних типів заголовків. Ці заголовки відрізняються за розміром шрифту, починаючи з найбільшого.h1 – найбільший заголовок. h6 – найменший заголовок. h1 має бути лише 1 на сторінці."
    },
    {
      "id": 7,
      "text": "Що таке семантична верстка?",
      "hasOptions": false,
      "answer": "Це верстка орієнтована на структурування html-документів. У ній використовуються теги, які поділяють код на логічні блоки, що явно показують їх роль та зміст у структурі сторінки. Семантична верстка відрізняється від блокової лише елементами, що використовуються при структуризації сторінки.У блоковій верстці використовують в основному тільки елемент div, а в семантичній використовуються крім div ще безліч інших тегів, таких як: header, main, section, footer, nav, aside."
    },
    {
      "id": 8,
      "text": "Що таке потік HTML-документа?",
      "hasOptions": false,
      "answer": "Потоком документа HTML називається порядок виведення елементів на сторінку. У звичайному вигляді всі блоки виводяться у порядку, у якому записані всередині HTML-документа. Потік можна змінювати за допомогою css правил, наприклад, за допомогою position: absolute."
    },
    {
      "id": 9,
      "text": "Як підключити JavaScript до сторінки?",
      "hasOptions": false,
      "answer": "Перший спосіб — вставити скрипт у блок script. Другий спосіб — підключити скрипт за допомогою додавання посилання на файл JavaScript. Бажано всі скрипти підключати наприкінці блоку body."
    },
    {
      "id": 10,
      "text": "Яка різниця між script, script async та script defer?",
      "hasOptions": false,
      "answer": "1 - Коли браузер завантажує HTML і доходить до тегу script, він призупиняє будувати DOM. Він повинен спочатку завантажити та виконати скрипт, і лише потім обробити решту сторінки. 2 - Атрибут defer повідомляє браузеру, що він повинен продовжувати обробляти сторінку та завантажувати скрипт у фоновому режимі, а потім запустити цей скрипт, коли сторінка завантажилася. 3 - Атрибут async повідомляє браузеру, що він повинен продовжувати обробляти сторінку та завантажувати скрипт у фоновому режимі, а потім запустити цей скрипт, як тільки він буде завантажений. "
    },
    {
      "id": 11,
      "text": "Як додати CSS на сторінку?",
      "hasOptions": false,
      "answer": "Перший спосіб — описати селектори та їх значення всередині тегу style. Другий спосіб — підключити стилі за допомогою додавання посилання на зовнішній файл css, використовують тег link, що розташовується всередині блоку head.Третій спосіб — додати інлайнові стилі для кожного окремого елемента, використовуючи атрибут style."
    },
    {
      "id": 12,
      "text": "Яка різниця між reset.css та normalize.css?",
      "hasOptions": false,
      "answer":"reset.css - скидає всі стилі в нуль для того, щоб можна було розпочати стилізацію сайту з чистого аркуша. normalize.css - приводить вихідні стилі до єдиного стану, у всіх браузерах."
    },
    {
      "id": 13,
      "text": "Що таке critical CSS?",
      "hasOptions": false,
      "answer": "Critical CSS - це стилі, які необхідні для відтворення першої видимої частини сторінки. Для моментального відтворення критичний CSS вбудовують в HTML, всі інші стилі завантажуються окремим файлом асинхронно."
    },
    {
      "id": 14,
      "text": "Що таке специфічність селекторів CSS?",
      "hasOptions": false,
      "answer": " Це спосіб, за допомогою якого браузери визначають, які значення властивостей CSS найбільше відповідають елементу і, отже, будуть застосовані. Специфічність є вагою, що надається конкретному правилу CSS. Найбільшу вагу мають inline стилі. Потім стилі селектора за ID. Найменшу вагу мають селектори по тегу і також селектор*."
    },
    {
      "id": 15,
      "text": "Яка різниця між псевдокласом і псевдоелементом в CSS?",
      "hasOptions": false,
      "answer":"Псевдокласи описують особливий стан елементу. Наприклад, стан натиснутої кнопки. Псевдоелементи відповідають віртуальним елементам. Наприклад, потрібно виділити першу літеру в рядку. "
    },
    {
      "id": 16,
      "text": "Що таке блокова модель CSS?",
      "hasOptions": false,
      "answer": "Кожен блок має прямокутну область вмісту в центрі, поля навколо вмісту (padding), рамку навколо полів (border) та відступ за межами рамки (margin)."
    },
    {
      "id": 17,
      "text": "Що робить властивість box-sizing?",
      "hasOptions": false,
      "answer": "Властивість box-sizing визначає як обчислюється загальна ширина та висота елемента. Має 2 поведінки:1. content-box це стандартна поведінка. Якщо встановити елементу ширину 100 пікселів, то ширина його контенту буде 100 пікселів, а ширина меж і внутрішніх відступів під час рендеру буде додана до фінальної ширини, що зробить елемент ширше ста пікселів.2. border-box каже браузеру враховувати будь-які межі та внутрішні відступи у значеннях, які вказані у ширині та висоті елемента. Якщо виставити елементу ширину 100 пікселів, то ці 100 пікселів будуть містити межі та внутрішні відступи, а контент стискається, щоб виділити для них місце. Зазвичай це полегшує роботу з розмірами елементів. "
    },
    {
      "id": 18,
      "text": "Які види позиціонування елементів на сторінці ви знаєте?",
      "hasOptions": false,
      "answer": "Існує 5 видів позиціонування: 1.static - стандартне позиціонування; 2.relative - позиціонування щодо самого себе; 3.absolute - позиціонування щодо його найближчого відносно позиціонованого предка, якщо такий є; 4.fixed - позиціонування відносно viewport 5.sticky - липке позиціонування, яке може змінювати своє значення з relative на fixed під час прокручування сторінки. "
    },
    {
      "id": 19,
      "text": "Що робить властивість z-index?",
      "hasOptions": false,
      "answer": " Ця властивість визначає положення елемента та елементів, розташованих нижче по осі z. У разі перекриття елементів це значення визначає порядок накладання. У загальному випадку елементи з більшим z-index перекривають елементи з меншим. Ця властивість працює тільки для елементів, у яких значення position встановлено як absolute, fixed або relative."
    },
    {
      "id": 20,
      "text": "Яка різниця між px, em, rem?",
      "hasOptions": false,
      "answer": "px - піксель, це найбільш базова, абсолютна та остаточна одиниця виміру;em - одиниця виміру відносно поточного розміру шрифту; rem - одиниця виміру відносно розміру шрифту елемента html."
    },
    {
      "id": 21,
      "text": "Яка різниця між гумовою, адаптивною та респонсивною версткою?",
      "hasOptions": false,
      "answer": "У гумовій верстці блоки змінюють ширину залежно від розміру вікна браузера. Адаптивна верстка реалізується за допомогою правил @media. Це дає змогу для кожного окремого розміру екрана відображати різну верстку. Будь-яка зміна розміру вікна відбувається ривками, після досягнення однієї із зазначених точок перелому.Респонсивна верстка — це поєднання гумової та адаптивної верстки. У реалізації найскладніша. Але результат виходить найбільш прийнятним. "
    },
    {
      "id": 22,
      "text": "Яка різниця між visibility:hidden та display:none?",
      "hasOptions": false,
      "answer":"visibility:hidden залишає елемент у нормальному потоці сторінки, і він все ще займає місце.display:none видаляє елемент із нормального потоку сторінки, що дозволяє іншим елементам заповнити його місце. "
    },
    {
      "id": 23,
      "text": "Для чого потрібне правило @supports?",
      "hasOptions": false,
      "answer": "Правило @supports дозволяє перевірити, чи підтримує браузер ту чи іншу можливість, і на основі цього створити набір стильових правил."
    },
    {
      "id": 24,
      "text": "Яка різниця між Progressive Enhancement та Graceful Degradation?",
      "hasOptions": false,
      "answer": "Прогресивне покращення – це коли основний функціонал програми однаково працює у всіх браузерах, а для нових браузерів додається щось додаткове. Це добре працює з технологіями, які поки що широко не підтримуються, але вже можуть принести користь. Для реалізації цього підходу використовується директива @supports.Поступова деградація – це коли код спочатку пишеться для найновіших браузерів з використанням останніх технологій, але при цьому додаток потребує підтримки старими браузерами. За такого підходу інтерфейс спрощується або деградує поступово, але при цьому ним все одно можна користуватися."
    },
    {
      "id": 25,
      "text": "Що таке repaint та reflow?",
      "hasOptions": false,
      "answer":"Під час завантаження сторінки, якщо вона не порожня, завжди виконується щонайменше по одному reflow та repaint. Далі ці події виникають у таких випадках:  1 - частина дерева відображення потребує перерахунку, тобто у якогось вузла змінилися ширина, висота чи координати. Викликається подія reflow.  2 - в результаті змін частина контенту, що відображається, повинна оновитися. Йдеться в першу чергу про властивості стилів: колір фону і т. д. Викликається подія repaint. Якщо викликається reflow, після нього обов'язково викликається і repaint. Але зворотне хибно: repaint може викликатися незалежно від reflow. "
    },
    {
      "id": 26,
      "text": "Яка різниця між cookie, sessionStorage та localStorage?",
      "hasOptions": false,
      "answer": " localStorage: 1. зберігає дані безстроково. 2. очищається тільки за допомогою JavaScript або чищення кешу браузера. 3. зберігає дані об'ємом до 5 МБ. 4. не підтримується старими браузерами, наприклад, IE 7 і нижче. 5. працює за правилом обмеження домену (same origin policy). sessionStorage: 1. зберігає дані, поки триває поточна сесія вкладки. 2. кожна вкладка має свій sessionStorage. 3. зберігає дані об'ємом до 5 МБ. 4. не підтримується старими браузерами, наприклад, IE 7 і нижче.cookie: 1. зберігає дані, що передаються на сервер через заголовки. 2. мають термін зберігання даних. 3. обсяг даних від 4 Кбайт до 32 Кбайт. 4. сookie можуть бути захищеними, в цьому випадку їх вміст не можна отримати на стороні клієнта. Це важливо для аутентифікації при зберіганні користувальницьких токенів. "
    },
    {
      "id": 27,
      "text": "Яка різниця між відносним та абсолютним шляхом?",
      "hasOptions": false,
      "answer":"Абсолютні адреси повинні починатися із зазначення протоколу (зазвичай http://) та містити ім'я сайту. (http://some-site.com/path) Відносні посилання ведуть відлік від кореня сайту чи поточного документа. (/path)"
    },
    {
      "id": 28,
      "text": "Яка різниця між тегом та елементом?",
      "hasOptions": false,
      "answer": "Теги використовують для позначення початку та кінця вмісту HTML елемента.Елемент складається з тегів та вмісту."
    },
    {
      "id": 29,
      "text": "Коли використовувати button, а коли *a*?",
      "hasOptions": false,
      "answer": "Кнопка — це функціональний елемент, тобто елемент, який відповідає за виконання певної функції після натискання на неї.Посилання — це елемент навігації, тобто елемент, який відповідає за взаємозв'язок розділів веб-ресурсу (або різних ресурсів) між собою."
    },
    {
      "id": 30,
      "text": "Для чого потрібний атрибут type у кнопки?",
      "hasOptions": false,
      "answer": "type визначає тип кнопки, який встановлює її поведінку у формі. На вигляд кнопки різного типу ніяк не відрізняються, але у кожної такої кнопки свої функції.Існує 3 типи: button, reset і submit. За замовчуванням встановлено значення submit."
    },
    {
      "id": 31,
      "text": "Для чого потрібний тег base?",
      "hasOptions": false,
      "answer": "Тег base призначений для документів, у яких використовується відносна адреса та ці документи можуть переноситися до іншої директорії без втрати зв'язку. Браузер шукає тег base, визначає повну адресу документа та коректно завантажує його. Також тег base використовують для задавання цільового вікна для всіх посилань на поточній сторінці."
    },
    {
      "id": 32,
      "text": "Яка різниця між checkbox та radio?",
      "hasOptions": false,
      "answer": "radio - створює перемикання між варіантами та дозволяє вибрати тільки один з них.checkbox - застосовується у формі для вибору кількох значень."
    },
    {
      "id": 33,
      "text": "Що таке наслідування стилів в CSS?",
      "hasOptions": false,
      "answer": "Коли вказується стиль елемента, частина властивостей може бути успадкована його дочірніми елементами та нащадками. Наприклад, якщо задати колір тексту для body, то всі дочірні елементи та нащадки його успадкують."
    },
    {
      "id": 34,
      "text": "Що таке каскадність в CSS?",
      "hasOptions": false,
      "answer": "Каскадність — це особливість CSS, за допомогою якої браузер визначає значення яких властивостей буде застосовано до елемента, коли виникає конфлікт властивостей. Конфлікт властивостей виникає, коли для елемента визначено кілька правил, селектори яких мають однакову специфічність і містять однакові властивості, але з різними значеннями."
    },
    {
      "id": 35,
      "text": "Яка різниця між контентними та декоративними зображеннями?",
      "hasOptions": false,
      "answer": "За допомогою контентних зображень до користувачів доноситься корисна інформація. Щоб додати контентне зображення на сторінку, в розмітці використовується тег img. Для таких зображень необхідно заповнювати атрибут alt, який описує те, що зображено на картинці.Декоративні зображення використовуються виключно для оформлення. Такі зображення не несуть для користувача корисну інформацію. Декоративні зображення слід реалізовувати за допомогою CSS."
    },
    {
      "id": 36,
      "text": "Чому у img та input немає псевдоелементів ::before, ::after?",
      "hasOptions": false,
      "answer": "Псевдоелементи ::before та ::after дають результат тільки для тих елементів, які мають вміст. А у img та input вмісту немає."
    },
    {
      "id": 37,
      "text": "Для чого потрібна функція calc в CSS?",
      "hasOptions": false,
      "answer": "Функція calc дозволяє розрахувати значення властивостей CSS під час їх визначення. Вона приймає як параметр математичний вираз, результат обчислення якого можна використовувати як значення CSS властивості."
    },
    {
      "id": 38,
      "text": "Що таке flex-контейнер та flex-елемент?",
      "hasOptions": false,
      "answer": "Flex-контейнер встановлює новий гнучкий контекст форматування для його вмісту. Flex-контейнером є той елемент, у якого задано властивість display: flex або display: inline-flex. Flex-елементом є кожен дочірній елемент flex-контейнера."
    },
    {
      "id": 39,
      "text": "Що таке flex-вісь?",
      "hasOptions": false,
      "answer": "Flexbox визначає поняття головної та допоміжної осі. Елементи flex завжди розміщуються вздовж головної осі. При цьому головна вісь може бути розташована горизонтально чи вертикально. Спочатку головна вісь розташована горизонтально з напрямком елементів справа наліво. Напрямок головної осі можна змінити за допомогою властивості flex-direction."
    },
    {
      "id": 40,
      "text": "Які відмінності у mobile first та desktop first підходів?",
      "hasOptions": false,
      "answer": "Mobile first орієнтований на вузькі екрани. Це підхід, коли стилі застосовуються спочатку до мобільних пристроїв. Розширені стилі та інші перевизначення для великих екранів потім додаються до таблиці стилів через медіазапити. Desktop first орієнтований на широкі екрани. Це підхід, при якому стилі застосовуються спочатку до великих пристроїв. Розширені стилі та перевизначення для менших екранів потім додаються до таблиці стилів через медіазапити."
    },
    {
      "id": 41,
      "text": "Які переваги svg перед png або jpeg?",
      "hasOptions": false,
      "answer": "1 - На відміну від растрової графіки, SVG не втрачає якості при масштабуванні. 2 - Браузеру не потрібно запитувати картинку у сервера, оскільки він сам її малює, отже, продуктивність підвищується. 3 - За допомогою CSS/JS можна змінювати параметри графіки на сайті, наприклад, фон, прозорість або межі. Також SVG можна анімувати. 4 - Об'єкти SVG важать набагато менше растрових зображень."
    },
    {
      "id": 42,
      "text": "Яка різниця між rgb, rgba та hex?",
      "hasOptions": false,
      "answer": "rgb - це змішування червоного, зеленого та синього кольору у відсотковому чи числовому співвідношенні для отримання потрібного кольору. rgba - це той же rgb тільки з альфа-каналом, який задає рівень непрозорості (0 – прозорий, 1 – непрозорий). hex - цей опис кольору заснований на 16-річному записі числа. "
    },
    {
      "id": 43,
      "text": "Чим відрізняється лінійний та радіальний градієнти?",
      "hasOptions": false,
      "answer": "Лінійний градієнт створюється за допомогою двох і більше кольорів, для яких задано напрямок розподілу. Якщо напрямок не вказано, використовується значення за замовчуванням — зверху-вниз. Радіальний градієнт відрізняється від лінійного тим, що кольори виходять із центру градієнта і рівномірно розподіляються назовні, набуваючи форми кола."
    }
  ],
  "javascript": [
    {
      "id": 1,
      "text": "Які типи даних присутні в JavaScript?",
      "hasOptions": false,
      "answer": "Існує 8 типів даних. 7 примітивних та 1 складний тип даних. Примітивні типи: number, string, boolean, symbol, bigInt, null, undefined. Складний тип - object. Він використовується для колекцій даних та для оголошення більш складних сутностей. Також він передається за посиланням, а прості типи даних за значенням."
    },
    {
      "id": 2,
      "text": "Що таке NaN?",
      "hasOptions": false,
      "answer": "NaN (not a number) - це значення, що отримується в результаті виконання числової операції над не числовим значенням. Його тип даних number. NaN не дорівнює самому собі. Перевірку на NaN можна зробити за допомогою Number.isNaN"
    },
    {
      "id": 3,
      "text": "Яка різниця між null та undefined?",
      "hasOptions": false,
      "answer": "undefined (невизначений) являє собою значення за замовчуванням: \n1 - змінної, яку оголосили без ініціалізації; \n2 - функції, яка нічого не повертає явно; \n3 - неіснуючої властивості об'єкта. null - це значення «відсутності значення». \nПрисвоюється змінній явно."
    },
    {
      "id": 4,
      "text": "Чим відрізняється строга і нестрога рівність (=== та ==)?",
      "hasOptions": false,
      "answer": "Строга рівність порівнює значення за типом даних та значенням. Нестроге приводить значення до одного типу, а потім ці значення порівнює."
    },
    {
      "id": 5,
      "text": "Чому результатом порівняння двох схожих об'єктів є false?",
      "hasOptions": false,
      "answer": "Тому що об'єкти - це типи даних, що передаються за посиланням. 2 однакові на вигляд об'єкта мають різні посилання, і тому операція порівняння повертатиме false."
    },
    {
      "id": 6,
      "text": "Як перевірити 2 об'єкти на ідентичність?",
      "hasOptions": false,
      "answer": "1 - використовувати JSON.stringify для приведення об'єктів у рядок та порівняти їх вже як 2 рядки. Такий підхід має обмеження. Якщо в об'єкті будуть методи або symbol - JSON.stringify не зможе конвертувати їх у рядок. \n2 - написати або використати з бібліотеки функцію deepEqual, яка буде проходити циклом по ключах двох об'єктів і перевірятиме значення цих ключів. Функція має працювати рекурсивно."
    },
    {
      "id": 7,
      "text": "Як зробити копію об'єкта?",
      "hasOptions": false,
      "answer": "Існує поняття глибокого та поверхневого копіювання. Глибоке - це копіювання об'єкта та всіх його рівнів вкладеності. Поверхневе - це копіювання лише першого рівня вкладеності, а для решти копіюється посилання. \nСпособи поверхневого копіювання: \n1 - використовувати spread оператор (...) \n2 - використовувати Object.assign() \nСпособи глибокого копіювання: \n1 - використовувати JSON.stringify - JSON.parse для конвертування об'єкта в рядок і потім назад. Має обмеження щодо копіювання методів та symbols \n2 - написати або використати з бібліотеки функцію deepClone яка буде рекурсивно проходитиме за ключами об'єкта та копіюватиме їх у новий об'єкт."
    },
    {
      "id": 8,
      "text": "Чим відрізняються змінні var, let та const?",
      "hasOptions": false,
      "answer":"var - змінну можна ініціалізувати після оголошення, можна змінювати, має функціональну область видимості, має hoisting. Зараз майже не використовують під час написання нового коду. \nlet - змінну можна ініціалізувати після оголошення, можна змінювати, має блокову область видимості, не має hoisting. \nconst - змінну обов'язково потрібно ініціалізувати під час оголошення, не можна змінювати, має блокову область видимості, не має hoisting."
    },
    {
      "id": 9,
      "text": "Як дізнатися чи є об'єкт масивом?",
      "hasOptions": false,
      "answer":"Для цього можна використати метод Array.isArray."
    },
    {
      "id": 10,
      "text": "Які перебираючі методи масивів ви знаєте?",
      "hasOptions": false,
      "answer": "Є такі методи: \n- forEach – для перебору масиву. \n- filter – для фільтрації масиву. \n- every/some – для перевірки масиву. \n- map – для трансформації масиву в масив. \n- reduce/reduceRight – для проходу по масиву з обчисленням значення. \n- sort - сортує масив."
    },
    {
      "id": 11,
      "text": "Як об'єднати масиви?",
      "hasOptions": false,
      "answer": "1 - Можна використовувати метод concat().\n2 - Можна використовувати spread оператор та об’єднати ці масиви в один загальний масив."
    },
    {
      "id": 12,
      "text": "Як дізнатися чи знаходиться елемент у масиві?",
      "hasOptions": false,
      "answer": "1 - Використати метод includes, який повертає true якщо елемент знаходиться у масиві. \n2 - Використати метод indexOf, який повертає індекс знайденого елемента в масиві або -1 якщо елемента в масиві немає. \n3 - також можна використати метод find, який повертає знайдений елемент, або повертає undefined."
    },
    {
      "id": 13,
      "text": "Що таке підняття (hoisting)?",
      "hasOptions": false,
      "answer": "Це механізм у JavaScript, в якому змінні та оголошення функцій, пересуваються вгору своєї області видимості перед тим, як код буде виконаний. Піднімаються змінні типу var та function declaration."
    },
    {
      "id": 14,
      "text": "Яким буде значення змінної var, якщо звернутися до неї до її оголошення?",
      "hasOptions": false,
      "answer": "Значенням змінної буде undefined."
    },
    {
      "id": 15,
      "text": "Що буде, якщо звернутися до змінної let/const до її оголошення?",
      "hasOptions": false,
      "answer": "Буде помилка типу ReferenceError. Змінної ще не існує"
    },
    {
      "id": 16,
      "text": "Що таке область видимості (Scope)?",
      "hasOptions": false,
      "answer": "Це місце, де (або звідки) ми маємо доступ до змінних або функцій. JS має 4 типи областей видимості: глобальна, функціональна, блокова (ES6) та область видимості eval."
    },
    {
      "id": 17,
      "text": "Чим Function Declaration відрізняється від Function Expression?",
      "hasOptions": false,
      "answer": "Function Expression створюється, коли виконання доходить до нього, а потім вже може використовуватися. \nFunction Declaration можна використовувати у всьому скрипті (або блоці коду, якщо функцію оголошено в блоці)."
    },
    {
      "id": 18,
      "text": "Чим стрілочна функція відрізняється від звичайної?",
      "hasOptions": false,
      "answer": "1 - Стрілочна функція не має власного this. Вона бере його за місцем створення. У звичайній функції this визначається під час виклику. \n2 - Стрілочна функція не має arguments. \n3 - Стрілочна функція не має prototype. \n4 - Стрілочна функція має короткий синтаксис неявного повернення значення."
    },
    {
      "id": 19,
      "text": "Чи існує аналог arguments для стрілочної функції?",
      "hasOptions": false,
      "answer": "Аналога немає. Але можна використовувати rest оператор (...) для того, щоб зібрати всі параметри з якими викликана функція в масив."
    },
    {
      "id": 20,
      "text": "Що таке лексичне оточення (Lexical Environment)?",
      "hasOptions": false,
      "answer": "Це властивості внутрішнього об'єкта функції, які створюються під час її виклику. Туди записуються аргументи, функції та змінні. Також там знаходиться посилання на зовнішнє лексичне оточення."
    },
    {
      "id": 21,
      "text": "Що є глобальним лексичним оточенням?",
      "hasOptions": false,
      "answer": "У несуворому режимі це window. У суворому - undefined."
    },
    {
      "id": 22,
      "text": "Що таке замикання (Closures)?",
      "hasOptions": false,
      "answer": "Це здатність функції під час створення запам'ятовувати посилання на змінні, функції та параметри, що знаходяться в поточному лексичному оточенні, а також у лексичному оточенні батьківської функції й так до глобального лексичного оточення. Замикання передбачає саме зовнішні змінні, а не саму функцію."
    },
    {
      "id": 23,
      "text": "Для чого використовують замикання?",
      "hasOptions": false,
      "answer": "1 - Часто для створення приватних змінних та функцій (інкапсуляція).\n2 - Для збереження проміжних параметрів виклику функції (каррування). "
    },
    {
      "id": 24,
      "text": "Що таке IIFE?",
      "hasOptions": false,
      "answer": "Immediately Invoked Function Expression - це функція, яка викликається або виконується одразу після створення або оголошення."
    },
    {
      "id": 25,
      "text": "Що таке this?",
      "hasOptions": false,
      "answer": "Це посилання на контекст виклику функції. Контекстом є об'єкт, який в цей момент виконує або викликає функцію. Для стрілочної функції — це об'єкт у якому вона створена, а у звичайній функції — яким вона викликана. \nКонтекстом може бути:\n1 - this в об'єкті — вказує на сам об'єкт \n2 - this в класі — вказує на екземпляр класу \n3 - глобальним контекстом є window (або undefined в режимі use strict)"
    },
    {
      "id": 26,
      "text": "Як можна підмінити контекст виклику функції?",
      "hasOptions": false,
      "answer": "Є 3 методи: call, apply, bind. call та apply викликають функцію із заданим контекстом. bind повертає нову функцію із вже назавжди прив'язаним контекстом."
    },
    {
      "id": 27,
      "text": "Чи можна змінити контекст функції, яку повернув метод bind?",
      "hasOptions": false,
      "answer": "Ні, bind прив'язує контекст назавжди. "
    },
    {
      "id": 28,
      "text": "Чи можна підмінити контекст виклику стрілочної функції?",
      "hasOptions": false,
      "answer": "Ні. Стрілочна функція не має методів call, apply, bind і своїх аналогів. Також вона використовує контекст у якому її створили, а не контекст у якому її викликали."
    },
    {
      "id": 29,
      "text": "Що таке прототип об'єкта?",
      "hasOptions": false,
      "answer": "Це шаблон об'єкта. Він використовується як запасний варіант для властивостей та методів, що існують у цьому об'єкті. Це також один зі способів обміну властивостями та функціональністю між об'єктами. Це основна концепція прототипного наслідування в JS."
    },
    {
      "id": 30,
      "text": "Як працює прототипне наслідування в JavaScript?",
      "hasOptions": false,
      "answer": "Коли ми хочемо прочитати властивість з об'єкта, а вона відсутня - JavaScript спробує прочитати його з прототипу об'єкта. Якщо властивості немає в прототипі, JavaScript намагатиметься його прочитати з прототипу прототипу, і т.д. доки властивість не буде знайдено або ланцюжок прототипів не закінчиться. У такому разі JavaScript поверне undefined."
    },
    {
      "id": 31,
      "text": "Як створити об'єкт у якому не буде прототипу?",
      "hasOptions": false,
      "answer": "Використати Object.create(). Цей метод приймає першим аргументом об'єкт, який буде прототипом об'єкта, який він поверне. Якщо ми викличемо Object.create() з аргументом null, буде створено об'єкт без прототипу."
    },
    {
      "id": 32,
      "text": "Як перевірити чи є властивість об'єкта особистою властивістю або це властивість прототипу?",
      "hasOptions": false,
      "answer": "Можна використовувати метод hasOwnProperty, який повертає true або false, в залежності від того, чи містить об'єкт зазначену властивість, як власну властивість, чи ні."
    },
    {
      "id": 33,
      "text": "Як заборонити змінювати об'єкт?",
      "hasOptions": false,
      "answer": "1 - Є метод Object.freeze(), який *заморожує* об'єкт від змін. Цей метод працює тільки в один бік. Скасувати дію цього методу вже неможливо. \n2 - Є метод Object.seal(), який забороняє додавати нові властивості, але вже наявні властивості можна змінювати.\n3 - Також є метод Object.preventExtensions(), який забороняє додавати нові властивості в об'єкт."
    },
    {
      "id": 34,
      "text": "Що таке дескриптори властивостей об'єкта?",
      "hasOptions": false,
      "answer": "Дескриптор — це об'єкт конфігурації властивості в об'єкті.\nВін має 4 властивості: \n- value - значення властивості об'єкта, \n- writable - вказує чи можна змінювати значення цієї властивості, \n- enumerable - вказує чи буде видно властивість під час перебору властивостей об'єкта, \n- configurable - вказує чи можна додавати або видаляти властивості об'єкта, а також чи можна змінювати дескриптори його властивостей."
    },
    {
      "id": 35,
      "text": "Чим відрізняється функція конструктор та клас?",
      "hasOptions": false,
      "answer": "Клас — це синтаксичний цукор над функцією конструктора. Під час створення екземпляра класу, методи описані в ньому потрапляють у прототип, а методи описані всередині функції конструктора потраплять у сам екземпляр. Для того, щоб методи, описані всередині функції конструктора, потрапили в прототип, їх потрібно окремо туди додати."
    },
    {
      "id": 36,
      "text": "Що потрібно зробити, щоб метод класу потрапив до його екземпляра?",
      "hasOptions": false,
      "answer": "Такий метод слід описати всередині конструктора."
    },
    {
      "id": 37,
      "text": "Чи є в JavaScript множинне наслідування?",
      "hasOptions": false,
      "answer": "Ні, тому що наслідування в JavaScript базується на прототипах, а в одного об'єкта може бути лише один прототип."
    },
    {
      "id": 38,
      "text": "Що таке Promise?",
      "hasOptions": false,
      "answer": "Це об'єкт, який використовують для відкладених та асинхронних обчислень. \nPromise має 3 стани: \n- очікування (pending): початковий стан, не виконаний та не відхилений. \n- виконано (fulfilled): операцію завершено успішно. \n- відхилено (rejected): операцію завершено з помилкою. "
    },
    {
      "id": 39,
      "text": "Для чого потрібен метод Promise.all?",
      "hasOptions": false,
      "answer": "Очікує виконання всіх промісів або відхилення будь-якого з них. Повертає проміс, який виконається після виконання всіх промісів. У випадку, якщо будь-який з промісів буде відхилено, Promise.all також буде відхилено. У нього є аналог Promise.allSetled, який виконується як тільки всі отримані проміси завершені (виконані або відхилені), що містить масив результатів виконання отриманих промісів."
    },
    {
      "id": 40,
      "text": "Для чого потрібен метод Promise.race?",
      "hasOptions": false,
      "answer": "Очікує виконання або відхилення будь-якого з отриманих промісів. Повертає проміс, який буде виконано або відхилено з результатом виконання першого виконаного або відхиленого промісу."
    },
    {
      "id": 41,
      "text": "Для чого потрібна async/await функція?",
      "hasOptions": false,
      "answer": "Ключове слово async робить створену функцію асинхронною. Функція async може містити вираз await, який призупиняє виконання функції async і чекає відповіді від переданого Promise, потім відновлює виконання функції async і повертає отримане значення."
    },
    {
      "id": 42,
      "text": "Як обробляти помилки в async/await функції?",
      "hasOptions": false,
      "answer": "1 - Для цього можна використовувати конструкцію try...catch()\n2 - викликати метод .catch() після виклику функції."
    },
    {
      "id": 43,
      "text": "Що таке event loop?",
      "hasOptions": false,
      "answer": "Це механізм, який відповідає за виконання коду, збору та обробки подій та виконання підзадач із черги.\nУ концепції event loop є кілька блоків: \n- call stack - відповідає за створення контексту виконання функції. Кожна функція, що викликається, потрапляє в call stack. \n- heap - це велика не структурована область пам'яті, в якій зберігаються оголошені змінні, функції тощо. \n- third party API - API, які надає оточення. Наприклад, метод fetch, який надається браузером. \n- queue - список завдань, що підлягають обробці. Кожне завдання асоціюється з деякою функцією, яка буде викликана, щоб опрацювати це завдання."
    }
    
  ],
  "react": [
    {
      "id": 1,
      "text": "Для чого потрібний Virtual DOM у React?",
      "hasOptions": false,
      "answer": " Віртуальний DOM - це концепція програмування, в якій «віртуальне» представлення інтерфейсу користувача зберігається в пам'яті та синхронізується з «справжнім» DOM за допомогою бібліотеки, такої як ReactDOM. Ця техніка дозволяє покращити продуктивність на клієнтській стороні, уникаючи прямої роботи з DOM шляхом роботи з легким JavaScript-об'єктом, що імітує DOM-дерево. "
    },
    {
      "id": 2,
      "text": "Яка різниця між virtual DOM та shadow DOM?",
      "hasOptions": false,
      "answer": "Virtual DOM - повне представлення реального DOM-дерева у вигляді JavaScript-об'єкта. Його найважливішою особливістю є групування змін та виконання одиночного рендерингу замість безлічі дрібних.\nShadow DOM - це нативна реалізація в браузері, яка дозволяє створити свій, ізольований, DOM. Всередині Shadow DOM створюється окремий *піддокумент*, до якого можна застосовувати свої стилі, екрановані від впливу зовнішнього середовища."
    },
    {
      "id": 3,
      "text": "Яка різниця між state та props?",
      "hasOptions": false,
      "answer": "props - передається в компонент ззовні.\nstate - внутрішній стан компонента."
    },
    {
      "id": 4,
      "text": "Яка різниця між класовим та функціональним компонентом?",
      "hasOptions": false,
      "answer": "У класових компонентів є state, а у функціональних його немає. Але стан для функціонального компонента можна додати за допомогою хука useState. У класових компонентів є методи життєвого циклу, а у функціональних його немає. Але деякі методи життєвого циклу для функціонального компонента можна реалізувати за допомогою хука useEffect. "
    },
    {
      "id": 5,
      "text": "Які методи життєвого циклу є в React?",
      "hasOptions": false,
      "answer": "В React є 3 фази: монтування, оновлення та розмонтування. У кожній із цих фаз є свої методи життєвого циклу. \nМонтування: \nЦі методи викликають у такому порядку, коли екземпляр компонента створюється і додається в DOM:\n- constructor() \n- static getDerivedStateFromProps() \n- render() \n- componentDidMount() \nОновлення:\nОновлення може бути викликане змінами у властивостях або стані. Ці методи викликається у такому порядку, коли компонент повторно відмальовується:\n- static getDerivedStateFromProps() \n- shouldComponentUpdate() \n- render() \n- getSnapshotBeforeUpdate() \n- componentDidUpdate() \nРозмонтування: \nЦей метод викликається коли компонент видаляється з DOM:\n- componentWillUnmount()\nОбробка помилок:\nЦей метод викликається при виникненні помилки під час рендеру, у методі життєвого циклу або в конструкторі будь-якого дочірнього компонента:\n- static getDerivedStateFromError()\n- componentDidCatch()"
    },
    {
      "id": 6,
      "text": "Як оновити state у класовому компоненті?",
      "hasOptions": false,
      "answer": "Для того, щоб оновити стан у класовому компоненті, можна використовувати метод setState. Цей метод є асинхронним і React може згрупувати кілька викликів setState() в одне оновлення для поліпшення продуктивності. Метод setState може приймати функцію для того, щоб оновити стейт на основі вже наявного state. Виклик методу setState завжди призводить до оновлення компонента."
    },
    {
      "id": 7,
      "text": "Чому setState асинхронна функція?",
      "hasOptions": false,
      "answer": "Це потрібно для того, щоб React зміг згрупувати кілька викликів setState() в одне оновлення для покращення продуктивності. Виклик setState призводить до оновлення компонента, тому setState зробили асинхронною, щоб *дочекатися* поки всі компоненти викличуть setState() у своїх обробниках подій, перш ніж почати повторний рендер. Це позбавляє непотрібних повторних рендерів."
    },
    {
      "id": 8,
      "text": "Що потрібно зробити, щоб компонент оновився?",
      "hasOptions": false,
      "answer": "Для того, щоб оновився компонент потрібно: \n- щоб змінився state, шляхом виклику метода setState.\n- щоб змінилися props.\n- викликати метод forceUpdate."
    },
    {
      "id": 9,
      "text": "Як запобігти зайвому оновленню компонента?",
      "hasOptions": false,
      "answer": "Існує кілька способів:\n- реалізувати метод життєвого циклу shouldComponentUpdate, який скасовує рендер, якщо з нього повернути значення false.\n- успадкуватися від PureComponent при створенні класового компонента."
    },
    {
      "id": 10,
      "text": "Яка особливість PureComponent?",
      "hasOptions": false,
      "answer":"В більшості випадків PureComponent можна використовувати замість написання власного shouldComponentUpdate. Але він робить лише поверхневе порівняння."
    },
    {
      "id": 11,
      "text": "Для чого потрібні key?",
      "hasOptions": false,
      "answer":"key - це спеціальний рядковий атрибут, який потрібно вказувати під час створення списку елементів. Ключі допомагають React визначати, які елементи були змінені, додані чи видалені. Їх необхідно вказувати, щоб React міг зіставляти елементи масиву з плином часу."
    },
    {
      "id": 12,
      "text": "Для чого потрібний компонент Fragment?",
      "hasOptions": false,
      "answer":"React компонент завжди повинен повертати тільки один елемент. Але іноді бувають завдання коли треба повернути кілька елементів. Фрагменти дозволяють формувати список дочірніх елементів, не створюючи зайвих вузлів в DOM. "
    },
    {
      "id": 13,
      "text": "Для чого потрібні портали?",
      "hasOptions": false,
      "answer":"Портали дозволяють рендерити дочірні елементи в DOM-вузол, що знаходиться поза DOM-ієрархією батьківського компонента."
    },
    {
      "id": 14,
      "text": "Що таке refs?",
      "hasOptions": false,
      "answer":"Рефи дають можливість отримати доступ до DOM-вузлів або React-елементів, створених у рендер-методі. Також рефи можуть зберігати в собі будь-яку іншу інформацію, окрім DOM-вузла."
    },
    {
      "id": 15,
      "text": "Що таке context?",
      "hasOptions": false,
      "answer":"У React-додатку дані передаються зверху вниз за допомогою props. Однак, подібний спосіб використання може бути надто громіздким для деяких типів props, які необхідно передавати до багатьох компонентів у додатку. Контекст надає спосіб ділитися такими даними між компонентами без необхідності явно передавати пропси через кожен рівень дерева. "
    },
    {
      "id": 16,
      "text": "Для чого потрібні render props?",
      "hasOptions": false,
      "answer":"Render props - це можливість компонентів React розділяти код між собою за допомогою пропа, значенням якого є функція. Компонент із рендер-пропом бере функцію, яка повертає React-елемент, і викликає її замість реалізації власного рендеру."
    },
    {
      "id": 17,
      "text": "Що таке HOCs?",
      "hasOptions": false,
      "answer":"Компонент вищого порядку – це функція, яка приймає компонент та повертає новий компонент. Це потрібно для того, щоб винести певну бізнес-логіку в одне місце та знову використовувати її шляхом композиції компонентів."
    },
    {
      "id": 18,
      "text": "Як реалізувати компонент запобіжника (Error Boundary)?",
      "hasOptions": false,
      "answer":"Запобіжники — це компоненти React, які виловлюють помилки JavaScript в будь-якому місці дерев їх дочірніх компонентів, зберігають їх у журналі помилок і виводять запасний UI замість дерева компонентів, що звалилося. Класовий компонент є запобіжником, якщо він реалізує хоча б один із методів життєвого циклу: static getDerivedStateFromError() або componentDidCatch()."
    },
    {
      "id": 19,
      "text": "Які можливості надають хуки?",
      "hasOptions": false,
      "answer":"Хуки дозволяють використовувати стан та інші можливості React без написання класів. Хуки дозволяють повторно використовувати логіку стану, не зачіпаючи дерева компонентів."
    },
    {
      "id": 20,
      "text": "Які правила використання хуків?",
      "hasOptions": false,
      "answer":"Хуки — звичайні JavaScript-функції, але є два правила, яких потрібно дотримуватися. Не викликайте хуки всередині циклів, умовних операторів чи вкладених функцій. Натомість завжди використовуйте хуки тільки всередині React-функцій або всередині власного хука, до повернення будь-якого значення з них. Також, при створенні власного хука, його ім'я має починатися з «use»."
    },
    {
      "id": 21,
      "text": " Для чого потрібний useEffect?",
      "hasOptions": false,
      "answer":"Хук useEffect дає можливість виконувати побічні ефекти у функціональному компоненті. \n- Якщо передати функцію в useEffect, вона буде викликатися після кожного рендеру та оновлення.\n- Якщо передати функцію та її залежність в useEffect, вона буде викликатися після рендеру і щоразу, коли її залежність змінюється. \n- Якщо передати функцію в useEffect, яка повертає іншу функцію, ця функція буде викликана перед розмонтуванням компонента."
    },
    {
      "id": 22,
      "text": "Чим відрізняється useEffect від useLayoutEffect?",
      "hasOptions": false,
      "answer":"- useEffect викликається після рендеру та оновлення компонента. \n- useLayoutEffect викликається синхронно перед рендером та оновленням компонента. useLayoutEffect запускається у тій же фазі, що і componentDidMount та componentDidUpdate. "
    },
    {
      "id": 23,
      "text": "Що таке лінива ініціалізація стану в useState та useReducer?",
      "hasOptions": false,
      "answer":"Коли початковий стан є результатом виклику якоїсь функції, його можна ініціалізувати *ліниво* для того, щоб при кожному оновленні компонента ця функція не викликалася. Для цього в useState або useReducer потрібно передати функцію, яка поверне початковий стан, і буде викликана лише один раз, під час першого рендеру."
    },
    {
      "id": 24,
      "text": "Чим useRef відрізняється від createRef?",
      "hasOptions": false,
      "answer":"Різниця в тому, що коли потрібно створити ref всередині функціонального компонента, використовуючи createRef, він буде створюватися щоразу, коли оновлюється компонент. Використовуючи useRef, він створюється 1 раз під час монтування."
    },
    {
      "id": 25,
      "text": "Для чого потрібні useMemo та useCallback?",
      "hasOptions": false,
      "answer":"- Хук useMemo буде повторно обчислювати мемоізоване значення лише тоді, коли значення якоїсь із залежностей змінилося. Ця оптимізація допомагає уникнути дорогих обчислень під час кожного рендеру.\n- Хук useCallback поверне мемоізовану версію колбека, який змінюється лише тоді, коли змінюються значення однієї із залежностей. Це корисно під час передачі колбеків оптимізованим дочірнім компонентам, які покладаються на рівність посилань для запобігання непотрібним рендерам."
    },
    {
      "id": 26,
      "text": "Для чого потрібний redux?",
      "hasOptions": false,
      "answer":"Redux - це бібліотека для керування станом програми. У звичайному додатку React компоненти мають свій state і можуть передавати його в якості props для дочірніх компонентів. У React-redux програмах є один глобальний state, на який підписуються компоненти, яким потрібно з нього читати дані."
    },
    {
      "id": 27,
      "text": "Поясніть redux data flow",
      "hasOptions": false,
      "answer":"Життєвий цикл даних у будь-якій Redux-програмі включає 5 кроків: \n1 - викликається dispatch(action). Action - це простий javascript-об'єкт, який описує що трапилося. \n2 - action потрапляє в middleware, і якщо це необхідно, запускає якийсь сайд-ефект. \n3 - redux-стор викликає функцію-редюсер із двома аргументами: поточне дерево стану (state) та екшен (action). \n4 - головний редюсер може комбінувати результат роботи кількох редюсерів у єдине дерево стану програми. \n5 - redux-стор зберігає повне дерево стану, яке повертає головний редюсер."
    },
    {
      "id": 28,
      "text": "Що таке redux middleware?",
      "hasOptions": false,
      "answer":"Redux middleware надають сторонню точку розширення між відправкою екшену і моментом, коли цей екшен досягає редюсера. Redux middleware часто використовують для логування, повідомлення про помилки, спілкування з асинхронним API, роутингу тощо."
    },
    {
      "id": 29,
      "text": "Де потрібно робити side effects в redux?",
      "hasOptions": false,
      "answer":"Redux натхненний функціональним програмуванням і з коробки виконання побічних ефектів у ньому немає місця. Зокрема функції редюсера завжди повинні бути чистими функціями типу (state, action) => newState. Однак, мідлвари Redux-а дозволяють перехоплювати екшени та додавати до них складну поведінку, що включає побічні ефекти."
    },
    {
      "id": 30,
      "text": "Що таке next() функція в redux middleware?",
      "hasOptions": false,
      "answer":"Виклик next (action) в middleware призведе до того, що дія буде передана наступному middleware, а потім в редюсер. Це потрібно, щоб дотримуватися ланцюжка викликів middleware."
    },
    {
      "id": 31,
      "text": "Для чого потрібні redux селектори?",
      "hasOptions": false,
      "answer":"Селектори — це гетери для стану redux. Як і гетери, селектори інкапсулюють структуру стану та можуть використовуватися повторно. Селектори також можуть обчислювати похідні властивості."
    },
    {
      "id": 32,
      "text": "Чим відрізняється action від action creator?",
      "hasOptions": false,
      "answer":"action - це об'єкт, який описує, що сталося. \naction creator - це функція, яка може приймати якісь параметри та повертає action."
    }
  ]
}
